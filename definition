// sidedist permet de savoir quel distance il ya avec le cote que ce soit x ou y 
// deltadist = sert a avance de pas en pas de case en case entiere.
// side c pour savoir ou est le prochain mur, et lautre pour savoir la distance dun mur entier. pour le dda.
// plus raydir et petit lpus delta est grand.


// raydir et petit je pense logiquement c quil vise un angle de case.
// dda 
// distance la prochaine intersection  - la case entiere.
 // Plus perpwalldist est petite, plus le mur est grand sur l'Ã©cran (effet de perspective).
// si perpwalldist = 1 alors lineh = WIN_H le mur fait tout lecran
// if = 2 alors lineh = win_h/2 le mur fais la moitie de lecran en hauteur

/*ðŸ”¹ Formule :

deltadistX = sqrt(1 + (rayDirY * rayDirY) / (rayDirX * rayDirX));
deltadistY = sqrt(1 + (rayDirX * rayDirX) / (rayDirY * rayDirY));

ðŸ“Œ Pourquoi ce calcul ?

    On imagine un grillage de cases (comme une carte en pixels).
    deltadistX : distance pour passer dâ€™une ligne verticale Ã  la suivante.
    deltadistY : distance pour passer dâ€™une ligne horizontale Ã  la suivante. */

/* ðŸ”¹ sidedist â†’ Distance actuelle jusquâ€™Ã  la prochaine intersection

ðŸ“Œ Stocke la distance du rayon jusquâ€™Ã  la prochaine ligne de grille verticale (sidedistX) et horizontale (sidedistY).

ðŸ”¹ Initialisation :*/


//side cest actuellement la distance
// et delta cest la distance de base.

// donc side pour savoir le prochain mur
// delta pour que le rayon se deplace de case en case par rapport a se prochain mur.

// -> dans cet exemple il est plus proche de l'horizontal du coup on avance de case en case de maniere horizontal.
